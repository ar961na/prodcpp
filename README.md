[1-3. Cmake](#q1)

[4-6. Git](#q4)

[7. waterfall vs agile](#q7)

[8. Алгоритм Флойда](#q8)

[9. Инварианты класса](#q9)

[10. Инкапсуляция](#q10)

[11. Модификатор доступа](#q11)

[12. Наследование](#q12)

[13. private / protected / public](#q13)

[14. malloc/free vs new/delete](#q14)

[15. Инициализация](#q15)

[16. Сужающие преобразования](#q16)

[17. «Наиболее неприятный анализ»](#q17)

[18. Двойная инициализация](#q18)

[19. Порядок инициализации](#q19)

[20. RVO](#q20)

[21-23. Полиморфизм](#q21)

[24. overloading vs overriding](#q24)

[25. virtual](#q25)

[26. override](#q26)

[27. Абстрактный класс](#q27)

[28. Значение по умолчанию](#q28)

[29. NVI](#q29)

[30. Может существовать шаблон виртуального метода?](#q30)

[31. Можно ли перегружать вирутальные функции?](#q31)

[32. overloading set](#q32)

[33-34. GoTo](#q33)

[35. RAII](#q35)

[36. Инвариант умного указателя с удинственным владением](#q36)

[37. Drill down behaviour](#q37)

[38-39. lvalue и rvalue](#q38)

[40. std::move](#q40)

[41. Правило 0, 3, 5](#q41)

[42-45. Умные указатели](#q42)

[46. ODR](#q46)

[47. Include guards](#q47)

[48. CV-квалификарторы](#q48)

[49. Манглирование имен](#q49)

[50-51. Перегрузки функций](#q50)

[52-53. Специализация классов](#q52)

[54. auto и decltype](#q54)

[57. «ленивые» и «энергичные» вычисления](#q57)

[58-59. SFINAE](#q58)

[60. Замена структурам разных размеров с современном C++](#q60)

[61-67. CRTP](#q61)

[68-71. required](#q68)

[72-74. concept](#q72)

[75. Универсальные ссылки и идеальная передача](#q75)

[76. std::move и std::forward](#q76)

[77. Пачки параметров. Свертки](#q77)

[78-90. Паттерны](#q78)

## <a id="q1">1. Cmake. Написать Cmake для проекта, состоящего из main.cpp, class1.h, class1.cpp. Стандарт С++-17.</a>
```
cmake_minimum_required(VERSION 3.5)
project(question1)

set(CMAKE_CXX_STANDARD 17)

set(HEADERS class1.h)
set(SOURCES main.cpp class1.cpp)

add_executable(${PROJECT_NAME} ${SOURCES} ${HEADERS})
```

Алгоритм сборки проекта с использованием Cmake:
1. Создать каталог сборки (например build) на уровне основного CmakeLists.txt и перейти в него.
2. `cmake -DCMAKE_BUILD_TYPE=Debug/Release ..`
   Данная команда сгенерирует необходимые файлы для сборки проекта в соответствии с конфигурацией.
   Примечание: «..» предназначен для выполнения CmakeLists.txt, находящегося на уровень выше текущего положения.
4. `Cmake --build . –jX`
   Х – максимальное количество одновременных процессов для использования при сборке.

## <a id="q2">2. Cmake. Алгоритм сборки библиотеки без зависимостей из исходных кодов, которые содержат CmakeLists.txt.</a>
```
cmake_minimum_required(VERSION 3.5)
project(question2)

set(CMAKE_CXX_STANDARD 17)

set(SOURCE_EXE main.cpp)
set(SOURCE_LIB foo.cpp)

add_library(foo STATIC ${SOURCE_LIB})
add_executable(main ${SOURCE_EXE})

target_link_libraries(main foo)
```

## <a id="q3">3. Cmake. Добавление сторонней прекомпилированной библиотеки к своему проекту.</a>
```
cmake_minimum_required(VERSION 3.5)
project(question3)

find_package(MyExternalLibrary REQUIRED)

add_executable(MyExecutable main.cpp)
target_link_libraries(MyExecutable PRIVATE MyExternalLibrary::MyExternalLibrary)
```

## <a id="q4">4. Git. Отличие checkout от switch.</a>
- Создание ветки и переход:
  
	`git checkout –b <Название новой ветки>`

	`git switch –c <Название новой ветки>`
- Переход на другую ветку:

	`git checkout <Название ветки>`

	`git switch <Название ветки>`

Отличие между **git checkout** и **git switch**: **git checkout** используется при переключение веток/для отката изменений в определенном файле

В новых версиях git функционал checkout разделен на:
- **git switch** – работа с ветками;
- **git restore** – работа с файлами.

## <a id="q5">5. Git. Отличия rebase/merge/cherry-pick.</a>
- **merge** - объединяет изменения из одной ветки в другую, создавая новый коммит, если есть слияния

	`git merge feature-branch`

- **rebase** - перемещает или переигрывает коммиты из одной ветки в другую, переписывая историю

	`git rebase main`

- **cherry-pick** - применяет конкретные коммиты из одной ветки в другую без слияния всей ветки

	`git cherry-pick <commit-hash>`

## <a id="q6">6. Git. Что нужно сделать, чтобы зафиксировать изменения в локальном репозитории и добавить их в удаленный репозиторий.</a>
```
# Добавление изменений в индекс (стадия)
git add 

# Фиксация изменений в локальном репозитории
git commit -m "Описание изменений"

# Отправка изменений в удаленный репозиторий
git push origin main
```

## <a id="q7">7. Отличия waterfall от agile.</a>
Waterfall (Каскадная модель): Линейная и последовательная модель разработки, где каждая фаза должна быть завершена перед началом следующей.

- Жесткий порядок этапов (требования, дизайн, реализация, тестирование, развертывание).
- Подходит для проектов с четкими и неизменными требованиями.

Agile (Гибкие методологии): Инкрементная и итеративная модель, ориентированная на гибкость и адаптацию к изменениям.

- Разработка происходит в коротких циклах (итерациях).
- Частые релизы и обратная связь от пользователей.
- Приветствуются изменения требований даже на поздних этапах.

## <a id="q8">8. Алгоритм Флойда.</a>
1. Начинают два указателя: заяц и черепаха;
2. Заяц за один ход продвигается вперед на два элемента, а черепаха на один;
3. Если они встретились, значит петля есть.

Проблемы подхода:
- Если необходимо написать метод reverse?
- Опять использовать алгоритм Флойда, проверяя нет ли петель и тем самым удваивать время работы?

## <a id="q9">9. Инварианты класса. Определение.</a>
- Предусловия эффективного метода reverse – список корректен, начинается и заканчивается нулем, без петлей;
- Проверять каждый раз – неэффективно и дорого;
- Утверждение, которое должно быть верно все время жизни объекта класса называется его инвариантом;
- Все методы списка упростятся, если будет гарантировано сохранение инвариант списка;
- Кто должен гарантировать сохранение инварианта?
  Гарантировать сохранение инвариантов в методе – обязанность разработчика.

Проблемы инвариантов:
- Однако, как запретить внешним функциям нарушать инварианты у объектов?
- Есть ли в С++ языковые средства, чтобы запретить всем кроме методов класса, работать с его состоянием?

## <a id="q10">10. Инкапсуляция. Определение.</a>
В языке С++ для инкапсуляции (скрытия состояния объекта) используется специальный механизм, позволяющий сохранить видимость состояния.
```
template <typename T> class list_t {
	struct node_t;
	node_t *top_, *back_;
public:
	size_t length() const;
};
```

- В структуре по умолчанию все поля public;
- С приватной частью могут работать только методы класса (но Дружба – это магия);
  В хорошо спроектированной программе – друзей нет!

Особенности инкапсуляции:
- инкапсуляция - свойство типа, а не объектов;
- разные шаблонные параметры - разные типы!
- инкапсуляция делает критически важными конструкторы (так как состояние нельзя изменить извне) и деструкторы (так как очистить извне также нельзя)

## <a id="q11">11. Модификатор доступа в классе по умолчанию. Модификатор доступа в структуре по умолчанию.</a>

В классе по умолчанию модификатор доступа - **private**.

В структуре по умолчаю модификатор доступа - **public**.

## <a id="q12">12. Наследование в классе по умолчанию.Наследование в структуре по умолчанию.</a>

Наследование - концепция ООП, которая позволяет определять новые классы как расширение существующих. Различают открытое (A является B) и закрытое (A содержит B).

Открытое наследование = контракт, где мы обещаем клиенту, что класс поддерживает методы класса родителя, сохраняет инварианты и тому подобное.

В классе по умолчанию тип наследования - **private**.

В структуре по умолчаю тип наследования - **public**.

## <a id="q13">13. Отличия private/protected/public (внутри определения класса и при наследовании).</a>

- private:
  Доступен только внутри самого класса. При наследовании private члены остаются недоступными для производного класса.
- protected:
  Доступен внутри самого класса и производных классов. При наследовании protected члены остаются доступными для производного класса и его производных.
- public:
  Доступен везде, где доступен объект. При наследовании public члены остаются доступными для всех.

```
class Base {
private:
    int privateVar;
protected:
    int protectedVar;
public:
    int publicVar;
};

class Derived : public Base {
    void access() {
        // privateVar недоступен
        protectedVar = 1; // доступен
        publicVar = 2; // доступен
    }
};
```

## <a id="q14">14. Отличие malloc/free от new/delete.</a>
C-шные **malloc** и **free** ничего не знают о конструкторах и деструкторах, поэтому используются **new** и **delete**, которые помимо выделения/очистки памяти вызывают конструктор/деструктор соответственно.

## <a id="q15">15. Когда не применима инициализация «в круглых скобках», «после =», «фигурная».</a>

```
list_t<int> T1;		// Вызов конструктора по умолчанию
list_t<int> T2 = T1;	// Не присваивание, а конструктор копирования
T1 = T2;		// Присваивание; вызов оператора operator=()

int x(0);	// Инициализатор в круглых скобках
int y = 0; 	// Инициализатор после "="
int z{ 0 };	// Инициализатор в круглых скобках - унифицированная инициализация
```

Инициализация полей класса по умолчанию:
```
class Point {
	...
private:
	int x{ 0 };	// ОК, значение x по умолчанию равно 0
	int y = 0; 	// Тоже ОК
	int z(0);	// Ошибка!
};
```

Для некопируемых объектов:
```
std::atomic<int> ai1 { 0 };	// OK
std::atomic<int> ai2 (0);	// OK
std::atomic<int> ai3 = 0;	// Ошибка!
```

## <a id="q16">16. Сужающие преобразованию и разные виды инициализации («в круглых скобках», «после =», «фигурная»).</a>

Особенности унифицированной инициализации: запрет сужающих преобразований
```
double x, y, z;

int sum1 { x + y + z };		// Warning/Error в зависимости от флагов компилятора
int sum2 ( x + y + z );		// OK
int sum3 = x + y + z;		// OK
```

## <a id="q17">17. «Наиболее неприятный анализ» в С++ и разные виды инициализации («в круглых скобках», «фигурная»).</a>

«Наиболее неприятный анализ» (Most Vexing Parse) - это ситуация, когда синтаксис C++ может быть неоднозначным.

### Пример 1:
```
class list_t {};

class my_class_t {
public:
	int x = 42;
	my_class_t(list_t, list_t) {};
}

int main (int argc, char** argv) {
	my_class_t m1(list_t(), list_t());
	std::cout << m1.x << std::endl;
	my_class_t m2 { list_t(), list_t() };
	std::cout << m2.x << std::endl;
}
```

Что будет выведено в обоих случаях?

> error: request for member 'x' in m1, which is of non-class type 'my_class_t(list_t (`*`)(), list_t (`*`)())' std::cout << m1.x << std::endl;

### Пример 2:

```
std::vector<int> a(10, 20);
std::vector<int> b{ 10, 20 };
std::cout << a.size() << " " << b.size() << std::endl;
```

Что будет выведено?

> 10 2

Так как при наличии конструктора, принимающего *std::initializer_list в качестве аргумента, будет использован именно этот конструктор даже когда он подходит не лучшим образом.

## <a id="q18">18. В каких случаях возникает двойная инициализация? Как избежать?</a>

```
#include <iostream>

struct S {
	S() { std::cout << "default" << std::endl; };
	S(int key) { std::cout << "direct" << std::endl; };
};

struct Node1 {
	S key_;
	int val_;
	Node1 (int key, int val) { key_ = key; val_ = val; };		// Двойная инициализация!!!
};

struct Node2 {
	S key_;
	int val_;
	Node2 (int key, int val) : key_{ key }, val_{ val } {};
};

int main (int argc, char** argv) {
	Node1 a(2, 3);			//!!!
	Node2 b(2, 3);
}
```

Присваивая в теле конструктора мы инициализируем дважды.

Чтобы уйти от двойной инициализации предусмотрены списки инициализации.

## <a id="q19">19. В каком порядке выполняется инициализация полей класса с использованием списков инициализации (в порядке расположения полей класса или в порядке, определенном в списке инициализации)?</a>

Список инициализации выполняется строго в том порядке, в каком поля определены в классе (а не в том, в каком они записаны в списке).

## <a id="q20">20. Что такое RVO? Пример?</a>

RVO (Return Value Optimization) - оптимизация компилятора, позволяющая в некоторых случаях не создавать локальный объект, который будет использован как возвращающее значение. Вместо этого возвращаемый объект будет сконструирован на месте вызова функции. Это позоваляет устранить лишний вызов конструктора перемещения/копирования.

```
struct foo {
	foo() { std::cout << "1 " << std::endl; };
	foo(const foo&) { std::cout << "2" << std::endl; };
	~foo() { std::cout << "3" << std::endl; };
}

void aa(const foo& f) { std::cout << "AA" << std::endl; };
foo bar() { foo loc_foo; return loc_foo; }

int main (int argc, char** argv) {
	foo f = bar();
	aa(f);
}
```

## <a id="q21">21. Полиморфизм. Определение. Виды полиморфизма.</a>

Полиморфизм - концепция ООП, которая позволяет для единого интерфейса представить множество реализаций в зависимости от аргументов.

Виды полиморфизма:
- **статический** (выбор реализации осуществляется во время компиляции) - перегрузки функций, шаблоны;
- **динамический** (выбор реализации осуществляется во время выполнения) - виртуальные функции.

## <a id="q22">22. Примеры статического полиморфизма в С++.</a>

```
template<typename T>
class Calculator {
public:
    	T add(T a, T b) {
        	return a + b;
    	}
};

Calculator<int> intCalc;
int result = intCalc.add(3, 5);
```

## <a id="q23">23. Примеры динамического полиморфизма в С++.</a>

```
class Shape {
public:
    	virtual void draw() const {
        	std::cout << "Drawing Shape" << std::endl;
    	}
    	virtual ~Shape() = default;
};

class Circle : public Shape {
public:
    	void draw() const override {
        	std::cout << "Drawing Circle" << std::endl;
    	}
};

Shape* shape = new Circle();
shape->draw(); // Вызовет Circle::draw
delete shape;

```

## <a id="q24">24. Отличие overloading от overriding.</a>

- Перегрузка функции (**overloading**) - введение того же имени с лругими типами аргументов;
- Переопределение функции (**overriding**) - замещение в классе наследнике виртуальной функции класса родителя.

## <a id="q25">25. Ключевое слово virtual.</a>

Ключевое слово **virtual** используется для создания виртуальных функций, которые могут быть переопределены в производных классах. Это позволяет добиться динамического полиморфизма.

## <a id="q26">26. Ключевое слово override.</a>

Аннотация override - требует переопределения.

## <a id="q27">27. Абстрактный класс. Определение.</a>

- Классы, в котором все методы чисто виртуальные служит своего рода общим;
- Класс, содержащий хотя бы одну чисто виртуальную функцию, называется абстрактным базовым классом;
- Виртуальный конструктор (в том числе копирующий) - невозможен.

## <a id="q28">28. Использование аргументов со значениями по умолчанию в виртуальных функциях.</a>

Аргументы по умолчанию для виртуальных функций должны быть заданы в базовом классе. Они будут использованы, если производный класс не переопределит эти значения.

```
class Base {
public:
    	virtual void display(int x = 5) {
       	 	std::cout << "Base: " << x << std::endl;
    	}
};

class Derived : public Base {
public:
    	void display(int x = 10) override {
        	std::cout << "Derived: " << x << std::endl;
    	}
};

int main (int argc, char** argv) {
	Base* b = new Derived();
	b->display(); 				// Выведет "Derived: 5"
}
```

## <a id="q29">29. NVI. Пример.</a>

NVI (Non-Virtual Interface):
- аргументы по умолчанию связываются статически, то есть зависят от статического типа;
- если нужен интерфейс с аргументами по умолчанию, его можно сделать невиртуальным, чтобы никто не смог из переопределить.

```
struct BaseNVI {
	int foo (int x = 14) { return foo_impl(x); };
private:
	virtual int foo_impl (int a) { return a; };
};

struct DerivedNVI {
	int foo_impl (int a) override { return a * 2; };
};
```

## <a id="q30">30. Может ли существовать шаблон виртуального метода?</a>

К счастью - нет.

## <a id="q31">31. Можно ли перегружать виртуальные функции?</a>

К сожалению - да.

## <a id="q32">32. Как добавить в overloading set класса-наследника методы базового класса, являющиеся перегрузками виртуального метода?</a>

Для добавления методов базового класса, являющихся перегрузками виртуального метода, нужно использовать директиву **using** в классе-наследнике.

```
class Base {
public:
    	virtual void func(int x) {
        	std::cout << "Base func with int: " << x << std::endl;
    	}
    	virtual void func(double y) {
        	std::cout << "Base func with double: " << y << std::endl;
    	}
};

class Derived : public Base {
public:
    	using Base::func; // Добавляем методы из базового класса
    	void func(int x) override {
        	std::cout << "Derived func with int: " << x << std::endl;
    	}
};

Derived d;
d.func(10); // Вызовет Derived func with int
d.func(5.5); // Вызовет Base func with double
```

## <a id="q33">33. Чем плох GoTo?</a>

- Ухудшает читаемость и поддержку кода;
- Приводит к трудноуловимым ошибкам;
- Нарушает структуру программы.

## <a id="q34">34. Примеры goto-маскирующих конструкций</a>

break, continue, case...

## <a id="q35">35. RAII. Концепция.</a>

RAII (Resource Acquisition Is Initialization) — это идиома, при которой ресурсы (память, файлы, сокеты и т.д.) связываются с временем жизни объектов. Ресурсы выделяются в конструкторе и освобождаются в деструкторе.

```
class File {
public:
    	File(const std::string& filename) : file(std::fopen(filename.c_str(), "r")) {
        	if (!file) {
            	throw std::runtime_error("Failed to open file");
        	}
    	}
    	~File() {
        	if (file) {
            	std::fclose(file);
        	}
    	}
private:
    	FILE* file;
};

void useFile() {
    	File f("example.txt"); 		// файл открыт
    	// использование файла
} 	// файл автоматически закрыт при выходе из useFile

```

## <a id="q36">36. Инвариант умного указателя с единственным (уникальным) владением.</a>

Инвариант умного указателя с уникальным владением (например, **std::unique_ptr**) заключается в том, что он владеет объектом эксклюзивно и гарантирует освобождение ресурса при его удалении. Копирование **std::unique_ptr** запрещено, но перемещение разрешено.

## <a id="q37">37. Drill down behaviour. Где применяется?</a>

Оператор -> можно использовать для работы с указателями на указатели, позволяя получать доступ к объектам на нескольких уровнях.

```
Point p1(1, 2);
Point* p2 = &p1;
Point** p3 = &p2;
(*p3)->display(); 	// Использование оператора -> с указателем на указатель
```

## <a id="q38">38. Lvalue и rvalue. Отличия.</a>

**lvalue** — это выражение, которое имеет адрес и может быть присвоено.
**rvalue** — это временное значение, которое не имеет адреса и не может быть присвоено.

Основные отличия между **lvalue** и **rvalue**:
- Адрес в памяти: **lvalue** имеет адрес в памяти, **rvalue** не имеет постоянного адреса.
- Использование в присваивании: **lvalue** может быть присваивающим выражением (располагаться слева от оператора присваивания), **rvalue** -  не может.
- Временное значение: **rvalue** — это временное значение, которое обычно существует на короткое время, **lvalue** — это долгоживущее значение.

```
int x = 10; 		// x — lvalue, 10 — rvalue
int& lref = x; 		// lref — lvalue-ссылка
int&& rref = 10; 	// rref — rvalue-ссылка
```

## <a id="q39">39. Rvalue ссылки.</a>

Rvalue-ссылки позволяют захватывать временные объекты для дальнейшего использования или модификации. Они обозначаются &&.

```
void process(int&& x) {
    	std::cout << "Processing: " << x << std::endl;
}

int main() {
    	process(5); 			// 5 — rvalue
    	int y = 10;
    	// process(y); 			// Ошибка, y — lvalue
    	process(std::move(y)); 		// std::move превращает y в rvalue
}
```

## <a id="q40">40. Что делает std::move?</a>

**std::move** преобразует **lvalue** в **rvalue**. Это используется для передачи владения временными объектами (например, для эффективного перемещения ресурсов).

```
std::string str = "Hello";
std::string newStr = std::move(str); 	// str теперь пустой, newStr владеет "Hello"
```

## <a id="q41">41. Правило нуля, трех, пяти.</a>

Правила нуля, трех и пяти касаются управления ресурсами и написания специальных функций-членов в C++:
- Правило нуля:
  Если класс не управляет ресурсами, полагаясь только на автоматическое управление памятью (например, стандартные контейнеры и умные указатели), не нужно определять никаких специальных функций (*конструктор копирования, оператор присваивания копирования, конструктор перемещения, оператор присваивания перемещения, деструктор*). Компилятор создаст их автоматически.
- Правило трех:
  Если класс управляет ресурсами (например, динамическая память, файлы, сокеты), то следует явно определить три функции: *конструктор копирования, оператор присваивания копирования и деструктор*.
- Правило пяти:
  В дополнение к правилу трех, если класс поддерживает семантику перемещения, необходимо определить еще две функции: *конструктор перемещения и оператор присваивания перемещения*.

## <a id="q42">42. Виды умных указателей.</a>

В стандартной библиотеке C++ есть три основных типа умных указателей:
- **std::unique_ptr**:

  Умный указатель с уникальным владением. Каждый unique_ptr владеет своим объектом и отвечает за его уничтожение. Невозможно скопировать unique_ptr, только переместить.
```
std::unique_ptr<int> ptr1 = std::make_unique<int>(10);
std::unique_ptr<int> ptr2 = std::move(ptr1); 			// ptr1 больше не владеет объектом
```
- **std::shared_ptr**:

  Умный указатель с разделенным владением. Несколько shared_ptr могут владеть одним объектом. Объект будет уничтожен, когда последний shared_ptr, ссылающийся на него, будет уничтожен.
```
std::shared_ptr<int> ptr1 = std::make_shared<int>(10);
std::shared_ptr<int> ptr2 = ptr1; 				// ptr1 и ptr2 владеют одним объектом
```
- **std::weak_ptr**:

  Умный указатель, который ссылается на объект, управляемый shared_ptr, но не влияет на время его жизни. Используется для устранения циклических зависимостей.
```
std::shared_ptr<int> sharedPtr = std::make_shared<int>(10);
std::weak_ptr<int> weakPtr = sharedPtr;
if (auto sp = weakPtr.lock()) {
    	// доступ к объекту через sp
}
```

## <a id="q43">43. Отличие unique_ptr от shared_ptr.</a>

- Владение:
	- **std::unique_ptr**: Уникальное владение (один указатель владеет объектом).
	- **std::shared_ptr**: Разделенное владение (несколько указателей могут владеть одним объектом).
- Передача владения:
	- **std::unique_ptr**: Может быть перемещен, но не скопирован.
	- **std::shared_ptr**: Может быть как скопирован, так и перемещен.
- Использование:
	- **std::unique_ptr**: Используется для объектов, которым нужен единственный владелец.
	- **std::shared_ptr**: Используется для объектов, которые могут иметь несколько владельцев.

## <a id="q44">44. Отличие weak_ptr от shared_ptr.</a>

- Владение:
	- **std::shared_ptr**: Владеет объектом, управляет его временем жизни.
	- **std::weak_ptr**: Не владеет объектом, не влияет на его время жизни.
- Циклические зависимости:
	- **std::weak_ptr** используется для предотвращения циклических зависимостей, которые могут возникнуть при использовании std::shared_ptr.
- Получение доступа к объекту:
	- **std::weak_ptr** предоставляет метод **lock()**, который возвращает **std::shared_ptr**, если объект еще существует.

## <a id="q45">45. Способы инициализации shared_ptr.</a>

- **std::make_shared**:
	```
	std::shared_ptr<int> ptr = std::make_shared<int>(10);
	```
- Конструктор с указателем:
	```
	std::shared_ptr<int> ptr(new int(10));
	```
- Перемещение из unique_ptr:
	```
	std::unique_ptr<int> uniquePtr = std::make_unique<int>(10);
	std::shared_ptr<int> ptr = std::move(uniquePtr);
	```
- Копирование и перемещение другого shared_ptr:
	```
	std::shared_ptr<int> ptr1 = std::make_shared<int>(10);
	std::shared_ptr<int> ptr2 = ptr1; 			// копирование
	std::shared_ptr<int> ptr3 = std::move(ptr2); 		// перемещение
	```

## <a id="q46">46. ODR.</a>

ODR (One Definition Rule) в C++ утверждает, что:
- Каждая сущность (например, функция, класс, переменная) должна иметь одно и только одно определение во всей программе.
- Можно иметь несколько объявлений одной и той же сущности, но только одно определение.

## <a id="q47">47. Include guards.</a>

Include guards защищают от множественного включения одного и того же заголовочного файла, что может привести к ошибкам компиляции. Используются директивы препроцессора #ifndef, #define и #endif.

## <a id="q48">48. CV-квалификаторы при выводе типов.</a>

CV-квалификаторы (const и volatile) влияют на вывод типов в C++. Они указывают, что объект не должен изменяться (const) или может изменяться в любой момент (volatile).

```
const int x = 10;
volatile int y = 20;
int z = 30;

const int* p1 = &z;      	// указатель на const int
int* const p2 = &z;      	// const указатель на int
const int* const p3 = &z; 	// const указатель на const int
```

## <a id="q49">49. Манглирование имен. (Как перегрузки функций представляются компилятором).</a>

Манглирование имен — это процесс преобразования имен функций и переменных, включающих типы параметров и возвращаемых значений, в уникальные имена для использования компилятором. Это необходимо для поддержки перегрузки функций.

```
extern "C" {
void func(int); 	// имя функции не будет манглироваться
}

void func(int);    	// манглированное имя может быть что-то вроде _Z4funci
void func(double); 	// манглированное имя может быть что-то вроде _Z4funcd
```

## <a id="q50">50. Правила разрешения перегрузки для нешаблонных функций.</a>

- Идеальное совпадение выигрывает;
- Все стандартные преобразования равны;
- Троеточия проигрывают почти всему.

## <a id="q51">51. Правила разрешения перегрузки для шаблонных функций.</a>

- Точно подходящая функция выигрывает у шаблона;
- Более специальный шаблон выигрывает у менее специального;
- Меньшее количество аргументов выигрывает против большего.

## <a id="q52">52. Что такое специализация шаблонного класса?</a>

Специализация - механизм языка программирования C++, предназначенный для специализации обобщенных шаблонных классов под конкретные задачи или под конкретное подмножество своих параметризованных данных.

```
template <typename T> class Stack {
	fwnode<T> *top_;
};
```

- Сигнатура специализированной функции обяхана повторять сигнатруру общего аблона и следовать за этим объявлением в коде.
  ```
  template <typename T> void foo(T x);
  template <> void foo<int> (int* x);		// fail, waiting for int
  ```
- Зато можно вообще не указывать специализирующий параметр, положившись на вывод типов.
  ```
  template <typename T> void foo(T x);
  template <> void foo (int* x);		// ok, T=int*
  ```
- В отличии от перегрузки специализация не трубет наличия параметра в сигнатуре функции (но тогда его, конечно, надо явно указать).
  ```
  template <typename T> void bar();
  template <> void bar<int>();			// fail, waiting for int
  ```
  Это сильный аргумент за специализацию.

### Пример:
```
template <typename T> void foo(T);	// 1
template <typename T> void foo(T*);	// 2
template <> void foo(int*);		// 3

int main() {
	int x;
	foo(&x);	// вызывает 3
}
```
Специализация (3) одинаково хорошо подходит для (1) и (2), поэтому специализируется *выигравший перегрузку* шаблон.

### Контрпример Димова-Абрамса:
```
#include <iostream>

template <typename T> void foo(T);	// 1
template <> void foo(int*);		// 2
template <typename T> void foo(T*);	// 3

int main() {
	int x;
	foo(&x);	// вызывает 3, хотя 2 подходит лучше
}
```
Специализации не участвуют в перегрузке: сначала разрешается перегрузка, потом пишется наименее общая специализация. В данном случае (2) не специализирует (3), так как встречается раньше.

Это аргумент против специализации.

### Контрольный пример:
```
template <typename T, typename U> void foo(T, U);	// 1
template <typename T, typename U> void foo(T*, U*);	// 2
template <> void foo<int*, int*>(int*, int*);		// 3

int main() {
	int x;
	foo(&x, &x);	// вызывает 2, так как 3 специализирует 1,
			// специализация не одинаково хорошо подходит для обоих
}
```

## <a id="q53">53. Что такое частичная специализация шаблонного класса?</a>

Частичная специализация шаблонного класса позволяет определять реализацию для шаблонного класса, которая будет применяться к подмножеству типов, удовлетворяющих определенному шаблонному параметру.

```
template <typename T>
class MyClass {};

template <typename T>
class MyClass<T*> {
public:
    void display() {
        std::cout << "Pointer specialization" << std::endl;
    }
};

MyClass<int*> obj;
obj.display();  // Output: Pointer specialization
```

## <a id="q54">54. Правила вывода типов для auto.</a>
- **auto** выводит типы так же как шаблоны функций с теми же правилами для уточненных:
  ```
  const int& x = 42;
  auto y = x;		// int y = x;
  auto& z = x;		// int& z = x;

  int const * const px = &x;
  auto py = px;			// int const * py = px;
  auto *pz = px;		// int const * const pz = px;
  ```
- дополнительные правила:
  ```
  auto x = new auto('c');	// char *c = new char('c');
  auto a = 1, b = 1.0;		// error
  auto y {1};			// int y {1};
  auto z = {1};			// std::initializer_list<int> z = {1};

Возможные проблемы:
- **auto** деградирует типы:
  ```
  void foo (float x) {
  	// ...
  	auto tmp = x;		// float tmp = x;
  }
  ```
- что может привести к неприятным последствиям:
  ```
  void foo (const float& x) {
  	// ...
  	auto tmp = x;		// float tmp = x;
  }
  ```

## <a id="q55">55. Что делает decltype?</a>

- **decltype(name)** - вывод точного типа name:
  ```
  void foo (float x) {
  	// ...
  	decltype(x) tmp = x;		// float tmp = x;
  }
  ```
- теперь все работает правильно:
  ```
  void foo (const float& x) {
  	// ...
  	decltype(x) tmp = x;		// const float& tmp = x;
  }
  ```

- **decltype** всегда выводит точный тип:
  ```
  const int& x = 42;
  decltype(x) y = 42;			// const int& y = 42;
  ```
- НО:
  ```
  struct Point { float x, y; };
  Point point { 1.f, 1.f };
  const Point& p = point;
  decltype(p.x) z1 = 42;		// int z1 = 42;				- decltype(id-expr)
  decltype((p.x)) z2 = 42;		// const int& z2 = 42;		- decltype(expr)
  ```
  Если в **decltype(expr)** **expr** - **lvalue**, тщ к типу добавляется **lvalue referenece**.

- **decltype(auto)** - еще ленивее:
  ```
  double x = 42;
  decltype(x) y = x;		// два раза x
  decltype(auto) z = x;		// а тут нет
  ```
- НО:
  ```
  decltype(auto) y1 = x; 	// double y1 = x
  decltype(auto) y2 = (x);	// double& y2 = x

Для вывода неизвестного типа возвращаемого значения лучше использовать расширенный синтаксис объявления функции:
```
template <class T>
auto makeAndProcess(const T& builder) -> decltype(builder.create())
{
	auto res = builder.create();
	// ...
	return res;
}
```

## <a id="q56">56. Когда используем auto, а когда decltype для вывода типов?</a>

Для точного вывода типа возвраащемого значения:
- **auto** в возвращаемом значении функции также приводит к деградации типа;
- снова помогает **decltype(auto)**.

Для принудительной деградации типа:
- **auto** деградирует тип по умолчанию;
- но если не хотим использовать значение x, то **decltype(x)**;
- также помогает **std::decay_t**.

## <a id="q57">57. Когда С++ осуществляет «ленивые», а не «энергичные» вычисления?</a>
```
int foo (int x, int y) { return (x > 3) ? 0 : y; }
foo(a + 3, b + 2);
```

EAGER:
```
calc a + 3
calc b + 2
invoke foo
test x > 3
	-> return 0
	-> return y
```

LAZY:
```
invoke foo
calc a + 3
test x > 3
	-> return 0
	-> calc b + 2
	   return y
```
- при сокращенных вычислениях
- при инстанцировании шаблонов

Но если подстановка в некотором контексте не может быть выполнена?

## <a id="q58">58. SFINAE. Определение.</a>

SFINAE (Substitution Failure Is Not An Error) - это правило C++ шаблонов, согласно которому ошибки подстановки шаблонных параметров не приводят к ошибкам компиляции, если существует альтернативная перегрузка функции или шаблона.

## <a id="q59">59. Зачем в старом С++ (до С++11) для реализации SFINAE создавались структуры разных размеров?</a>

До C++11 для реализации SFINAE использовались структуры разных размеров, чтобы различать успешные и неуспешные подстановки шаблонов. Это позволило компилятору выбирать правильные перегрузки функций.

Нет **std::is_class** и **constexpr** и интегральных констант???

## <a id="q60">60. Замена структурам разных размеров в современном С++.</a>

С появлением C++11 и последующих стандартов, такие техники были заменены более удобными средствами, такими как **std::enable_if** и **constexpr** функции.

Пример с использованием **std::enable_if**:
```
template <typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
void func(T t) {
    // функция активна только для целочисленных типов
}
```

## <a id="q61">61. CRTP. Определение. Зачем нужно.</a>

CRTP (Curiously Recursive Template Pattern) - это идиома программирования на C++, когда класс-шаблон использует производный класс в качестве параметра шаблона. Это позволяет использовать статический полиморфизм (выбор реализации во время компиляции).

Это ускорит программу. Посредством CRTP вызов функции занимает ровно столько времени, сколько и вызов обычной.

Почему CRTP  вообще работает? Понятно, что в точке, где тип B<D> должен быть известен, тип D еще не объявлен. Так не может быть - для объявления класса D необходимо точно знать, что представляет свобой базовый класс B<D>. Но если класс D еще не объявлен, то как компилятор знает, что идентификатор D вообще относится к классу? Ведь не можем же мы конкретизировать шаблон совершенно неизвестным типом.

## <a id="q62">62. Ограничения CRTP.</a>

Основное ограничение CRTP заключается в том, что размер базового класса B не может зависеть от параметра шаблона D. Вообще, шаблон класса B конкретизируется неполным типом D.

## <a id="q63">63. Реализация чисто виртуальных функций в CRTP.</a>

В CRTP виртуальные функции заменяются статическими вызовами, что позволяет избегать накладных расходов. Пррблема заключалась в том, что никто не заставляет переопределять функцию-член в производном классе, но если этого не сделать, что получается некорректная программа.
```
template <typename T> class B {
public:
	void f(int i) { static_cast<D*>(this) -> f_impl(i); }
};

class D : public B<D> {
public:
	void f_impl(int i) { i += i; }
};

int main() {
	B<D>* b;
	b->f(5);
}
```
Что случится, если мы забудем реализовать функцию D::f_impl()? Код не откомпилируется, потому что в классе D нет такой функции-члена: ни своей, ни унаследованной. Таким образом, мы реализовали чисто виртуальную функцию времени компиляции!

Можно разделить реализацию и интерфейс. 
```
template <typename T> class B {
public:
	void f(int i) { static_cast<D*>(this) -> f_impl(i); }
	void f_impl(int i) {}
};

class D : public B<D> {
public:
	void f_impl(int i) { i += i; }
};

class D1 : public B<D1> {
	// здесь нет f()
};

int main() {
	B<D>* b;
	b->f(5);		// вызывается D::f()

	B<D1>* b1;
	b1->f(5);		// вызывается B::f() по умолчанию
}
```

## <a id="q64">64. Реализация виртуальных функций в CRTP.</a>

Повтор вопроса.

## <a id="q65">65. Реализация методов для удаления объекта класса в CRTP.</a>

В деструкторе базового класса фактический объект уже не принадлежит производному типу, и вызов функций-членов производного класса приводит к неопределенному поведению.

Даже если это каким-то образом сработает, деструктор производного класса сделает свою работу, после чего вызовет деструктор базового класса - и мы получим бесконечный цикл.

Методы решения:
- использовать сторонние методы для удаления:
  `template <typename D> void destroy(B<D>* b) { delete static_cast<D*>(b); }
  - pros: соответствует паттерну CRTP;
  - cons: необходимо следить, чтобы объекты удалялись через destroy, а не через delete.
- сделать вирутальный деструктор:
  - pros: не надо следить за удалением;
  - cons:
    - возврвщаются накладные расходы на вызов вируальной функции, но это только для деструктора;
    - размер объекта увеличивается на размер указателя.

## <a id="q66">66. Способы применения CRTP.</a>
- Статический интерфейс
- Реестр объектов

## <a id="q67">67. Как применяется CRTP для делегирования?</a>

Чаще функция вызывается напрямую от имени объекта производного класса. Интерфейс и общий код находятся в базовом классе, а производные классы переопределяют конкретную реализацию. Это отношение сохраняется и тогда, когда обращение к CRTP-объекту производится через указатель или ссылку на базовый класс. Такое использование CRTP иногда называют статическим интерфейсом.

Если производный объект используется напрмяую, то ситуация кардинально меняется - базовый класс больше не определяет интерфейс, а производный является не только реализацией. Производный класс расширяет интерфейс базового, а базовый делегирует часть своего поведения производному.

## <a id="q68">68. Как работает ключевое слово required? Когда проверятся ограничения?</a>

**requires** используется для определения концептов и накладывания ограничений на шаблоны. Проверка требований происходит на этапе компиляции.

## <a id="q69">69. Чем плохи SFINAE ограничения? Приведите пример.</a>

SFINAE (Substitution Failure Is Not An Error) может привести к сложным и запутанным сообщениям об ошибках компиляции. Также сложность кода возрастает, что затрудняет его поддержку.

```
template <typename T>
auto func(T t) -> decltype(t.foo()) {
    return t.foo();
}

struct A {
    void foo() {}
};

struct B {};

int main() {
    A a;
    B b;
    func(a); // Компилируется
    func(b); // Ошибка компиляции
}
```

## <a id="q70">70. Что такое requires-expression? Отличия required-expression от required-clause</a>

**requires-expression** — это выражение, которое проверяет наличие определенных свойств или методов у типа.
```
template <typename T>
concept HasFoo = requires(T t) {
    { t.foo() } -> std::convertible_to<void>;
};
```

**requires-clause** — это условие, накладываемое на шаблонные параметры с использованием концептов.
```
template <typename T>
requires HasFoo<T>
void callFoo(T t) {
    t.foo();
}
```

Отличия:
- **requires-expression** проверяет валидность кода.
- **requires-clause** вычисляются на этапе компиляции.

## <a id="q71">71. Виды requires-expression</a>
- простые (simple) ограничения - являются истинным, если выражение валидно;
- ограничения типа (type) - являются истинными, если выражение - существующий тип;
- составные (compound) ограничения - являются комбинацией простого ограничения и ограничения типа, проверяют совместимость типа с выражением;
- вложенные (nested) ограничения - содержат **requires-clause**.

```
requires(T t, U u) {
	u + t;				// простое ограничение
	typename T::inner;	// ограничение типа
}
```

## <a id="q72">72. Что такое концепт? Особенности синтаксиса ограничения функций концептами</a>

Концепты позволяют создать аббревиатуру для **requires-expression** и по своей сути похожи на **constexpr bool**.
```
template <class From, class To>
concept convertible_to = std::is_convertible_v<From, To> && requires(From(&f)()) { static_cast<To>(f()); };
```

```
template <typename T>
concept Incrementable = requires(T t) {
    t++;
};

template <Incrementable T>
void increment(T& t) {
    t++;
}
```

## <a id="q73">73. Отношения между концептами</a>
Концепты могут быть зависимыми и составными. Один концепт может зависеть от другого концепта.
```
template <typename T>
concept Incrementable = requires(T t) {
    t++;
};

template <typename T>
concept Decrementable = requires(T t) {
    t--;
};

template <typename T>
concept Arithmetic = Incrementable<T> && Decrementable<T>;
```

## <a id="q74">74. Напишите концепт Hashable, принимающий одну шаблонную переменную T, который будет использоваться для проверки: существования типа std::hash<T>, существования std::hash<T>::operator() и приводимости типа возвращаемого значения std::hash<T>::operator() к std::size_t</a>
```
#include <functional>
#include <type_traits>

template <typename T>
concept Hashable = requires(T a) {
    { std::hash<T>{}(a) } -> std::convertible_to<std::size_t>;
};
```

## <a id="q75">75. Универсальные ссылки и идеальная передача</a>
Универсальные ссылки (universal references) — это ссылки, которые могут быть как lvalue, так и rvalue. Универсальные ссылки возникают при использовании T&& в шаблонах.

```
template <class T>
void foo(T&& x) {};

int main() {
	foo(5);		// T = int, decltype(x) = int&&
	int x = 5;
	foo(x);		// T = int&, decltype(x) = int&
	return 0;
}
```

Идеальная передача (perfect forwarding) — это техника, позволяющая передавать аргументы функции таким образом, чтобы сохранять их rvalue или lvalue состояние.

```
struct A {
	A() { std::cout << "default constructor" << std::endl; }
	A(const A&) { std::cout << "copy constructor" << std::endl; }
	A(A&&) { std::cout << "move constructor" << std::endl; }
};

int foo(A, A) { return 0; }

template <class F, class T1, class T2>
auto wrapper(F f, T1&& x, T2&& y)
{
	return f(std::forward<T1>(x), std::forward<T2>(y));
}

int main() {
	wrapper(foo, A{}, A{});
	return 0;
}
```

Сворачивание ссылок: («Одиночный амперсанд всегда побеждает»)
* & + & -> &
* & + && -> &
* && + & -> &
* && + && -> &&

## <a id="q76">76. Функции std::move и std::forward</a>
- **std::move**: Преобразует **lvalue** в **rvalue**.
  ```
  template <class T>
  std::remove_reference_t<T>&& move(T&& p) noexcept
  {
      return static_cast<std::remove_reference_t<T>&&>(p);
  }
  ```
- **std::forward**: возвращает (**lvalue** или **rvalue**) в зависимости от типа шаблонного параметра.
  ```
  template <typename T>
  T&& forward(std::remove_reference_t<T>& t) noexcept
  {
  	  return static_cast<T&&>(t);
  }
  ```

## <a id="q77">77. Пачки параметров. Как выделить паттерн раскрытия? Что такое свертки?</a>
Шаблон может принимать неопределенное количество аргументов
```
template <class... ARGS>
void f(ARGS... args);

int main() {
	f();			// пустая пачка
	f(42);			// int
	f(42, 4.2);		// int, double
}
```
Узнать размер пачки можно при помощи вызова sizeof...(ARGS) или sizeof...(args).

Параметры в пачке можно «раскрыть» согласно паттерну раскрытия:
```
// g(int x, double y);

template <class... ARGS>
void g(ARGS... args) {
	f(args...);					// f(x, y)
	f(&args...);				// f(&x, &y)
	f(h(args)...);				// f(h(x), h(y))
	f(const_cast<const ARGS*>(&args)...);		// f(const_cast<const int*>(&x), const_cast<const double*>(&y))
}
```

Свертки (fold expressions) — это механизм C++17 для применения бинарного оператора ко всем элементам пачки параметров.

| Паттерн свертки | Результат свертки |
|-----------------|-------------------|
|... op pack|(...(p1 op p2) op p3)...) op pN)|
|init op ... op pack|(...(init op p2) op p3)...) op pN)|
|pack op ...|(p1 op (p2 op (...(pN-1 op pN)...)|
|pack op ... op fini|(p1 op (p2 op (...(pN-1 op fini)...)|

```
template <class... ARGS>
auto sumAll(ARGS&&... args) { return (std::forward<ARGS>(args) + ...); }

template <class... ARGS>
auto printAll(ARGS&&... args) { (std::cout << ... << args) << std::endl; }
```

Свертки с пустыми пачками:
```
template <class... ARGS>
auto andAll(ARGS&&... args) { return (... && args); }

auto x = sumAll(); 	// ошибка компиляции оператор + не поддерживает пустые свертки
auto y = andAll();	// ОК: оператор && поддерживает пустые свертки
```

## <a id="q78">78. Паттерн Декоратор.</a>

## <a id="q79">79. Применение CRTP при реализации паттерна Декоратор.</a>

## <a id="q80">80. Паттерн Адаптер</a>

## <a id="q81">81. Минусы паттерна декоратор при реализации потокобезопасной очереди.</a>

## <a id="q82">82. Отличие паттерна декоратор от паттерна Адаптер.</a>

## <a id="q83">83. Паттерн Фабрика</a>

## <a id="q84">84. Как реализовать фабрику для инициализации объектов с разными аргументами в их конструкторах?</a>

## <a id="q85">85. Как реализовать полиморфное копирование с использованием фабрики?</a>

## <a id="q86">86. Зачем использовать CRTP в реализации полиморфного копирования с использованием фабрики?</a>

## <a id="q87">87. Паттерн Мост</a>

## <a id="q88">88. COW: достоинства и недостатки</a>

## <a id="q89">89. Паттерн Компоновщик</a>

## <a id="q90">90. Паттерн Строитель</a>
