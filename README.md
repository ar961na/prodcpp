[1-3. Cmake](#q1)


[4-6. Git](#q4)


[7. waterfall vs agile](#q7)


[8. Алгоритм Флойда](#q8)


[9. Инварианты класса](#q9)


[10. Инкапсуляция](#q10)


[11. Модификатор доступа](#q11)


[12. Наследование](#q12)


[13. private / protected / public](#q13)


[14. malloc/free vs new/delete](#q14)


[15. Инициализация](#q15)


[16. Сужающие преобразования](#q16)


[17. «Наиболее неприятный анализ»](#q17)


[18. Двойная инициализация](#q18)


[19. Порядок инициализации](#q19)


[20. RVO](#q20)


[21-23. Полиморфизм](#q21)


[24. overloading vs overriding](#q24)


[25. virtual](#q25)


[26. override](#q26)


[27. Абстрактный класс](#q27)


[28. Значение по умолчанию](#q28)


[29. NVI](#q29)


[30. Может существовать шаблон виртуального метода?](#q30)


[31. Можно ли перегружать вирутальные функции?](#q31)


[32. overloading set](#q32)


[33-34. GoTo](#q33)


[35. RAII](#q35)


[36. Инвариант умного указателя с удинственным владением](#q36)


[37. Drill down behaviour](#q37)


[38-39. lvalue и rvalue](#q38)


[40. std::move](#q40)


[41. Правило 0, 3, 5](#q41)


[42-45. Умные указатели](#q42)


[46. ODR](#q46)


[47. Include guards](#q47)


[48. CV-квалификарторы](#q48)


[49. Манглирование имен](#q49)


[50-51. Перегрузки функций](#q50)


[52-53. Специализация классов](#q52)


[54. auto и decltype](#q54)


[57. «ленивые» и «энергичные» вычисления](#q57)


[58-59. SFINAE](#q58)


[60. Замена структурам разных размеров с современном C++](#q60)


[61-67. CRTP](#q61)


[68-71. required](#q68)


[72-74. concept](#q72)


[75. Универсальные ссылки и идеальная передача](#q75)


[76. std::move и std::forward](#q76)


[77. Пачки параметров. Свертки](#q77)


[78-90. Паттерны](#q78)

## <a id="q1">1. Cmake. Написать Cmake для проекта, состоящего из main.cpp, class1.h, class1.cpp. Стандарт С++-17.</a>
```
cmake_minimum_required(VERSION 3.5)
project(question1)

set(CMAKE_CXX_STANDARD 17)

set(HEADERS class1.h)
set(SOURCES main.cpp class1.cpp)

add_executable(${PROJECT_NAME} ${SOURCES} ${HEADERS})
```

Алгоритм сборки проекта с использованием Cmake:
1. Создать каталог сборки (например build) на уровне основного CmakeLists.txt и перейти в него.
2. ```cmake -DCMAKE_BUILD_TYPE=Debug/Release ..```
   Данная команда сгенерирует необходимые файлы для сборки проекта в соответствии с конфигурацией.
	Примечание: «..» предназначен для выполнения CmakeLists.txt, находящегося на уровень выше текущего положения.
3. ```Cmake --build . –jX```
   Х – максимальное количество одновременных процессов для использования при сборке.

## <a id="q2">2. Cmake. Алгоритм сборки библиотеки без зависимостей из исходных кодов, которые содержат CmakeLists.txt.</a>
```
cmake_minimum_required(VERSION 3.5)
project(question2)

set(CMAKE_CXX_STANDARD 17)

set(SOURCE_EXE main.cpp)
set(SOURCE_LIB foo.cpp)

add_library(foo STATIC ${SOURCE_LIB})
add_executable(main ${SOURCE_EXE})

target_link_libraries(main foo)
```

## <a id="q3">3. Cmake. Добавление сторонней прекомпилированной библиотеки к своему проекту.</a>
```
cmake_minimum_required(VERSION 3.5)
project(question3)

find_package(MyExternalLibrary REQUIRED)

add_executable(MyExecutable main.cpp)
target_link_libraries(MyExecutable PRIVATE MyExternalLibrary::MyExternalLibrary)
```

## <a id="q4">4. Git. Отличие checkout от switch.</a>
- Создание ветки и переход:
  
	`git checkout –b <Название новой ветки>`

	`git switch –c <Название новой ветки>`
- Переход на другую ветку:

	`git checkout <Название ветки>`

	`git switch <Название ветки>`

Отличие между **git checkout** и **git switch**: **git checkout** используется при переключение веток/для отката изменений в определенном файле

В новых версиях git функционал checkout разделен на:
- **git switch** – работа с ветками;
- **git restore** – работа с файлами.

## <a id="q5">5. Git. Отличия rebase/merge/cherry-pick.</a>
- **merge** - объединяет изменения из одной ветки в другую, создавая новый коммит, если есть слияния

	`git merge feature-branch`

- **rebase** - перемещает или переигрывает коммиты из одной ветки в другую, переписывая историю

	`git rebase main`

- **cherry-pick** - применяет конкретные коммиты из одной ветки в другую без слияния всей ветки

	`git cherry-pick <commit-hash>`

## <a id="q6">6. Git. Что нужно сделать, чтобы зафиксировать изменения в локальном репозитории и добавить их в удаленный репозиторий.</a>
```
# Добавление изменений в индекс (стадия)
git add 

# Фиксация изменений в локальном репозитории
git commit -m "Описание изменений"

# Отправка изменений в удаленный репозиторий
git push origin main
```

## <a id="q7">7. Отличия waterfall от agile.</a>
Waterfall (Каскадная модель): Линейная и последовательная модель разработки, где каждая фаза должна быть завершена перед началом следующей.

- Жесткий порядок этапов (требования, дизайн, реализация, тестирование, развертывание).
- Подходит для проектов с четкими и неизменными требованиями.

Agile (Гибкие методологии): Инкрементная и итеративная модель, ориентированная на гибкость и адаптацию к изменениям.

- Разработка происходит в коротких циклах (итерациях).
- Частые релизы и обратная связь от пользователей.
- Приветствуются изменения требований даже на поздних этапах.

## <a id="q8">8. Алгоритм Флойда.</a>
1. Начинают два указателя: заяц и черепаха;
2. Заяц за один ход продвигается вперед на два элемента, а черепаха на один;
3. Если они встретились, значит петля есть.

Проблемы подхода:
- Если необходимо написать метод reverse?
- Опять использовать алгоритм Флойда, проверяя нет ли петель и тем самым удваивать время работы?

## <a id="q9">9. Инварианты класса. Определение.</a>
- Предусловия эффективного метода reverse – список корректен, начинается и заканчивается нулем, без петлей;
- Проверять каждый раз – неэффективно и дорого;
- Утверждение, которое должно быть верно все время жизни объекта класса называется его инвариантом;
- Все методы списка упростятся, если будет гарантировано сохранение инвариант списка;
- Кто должен гарантировать сохранение инварианта?
  Гарантировать сохранение инвариантов в методе – обязанность разработчика.

Проблемы инвариантов:
- Однако, как запретить внешним функциям нарушать инварианты у объектов?
- Есть ли в С++ языковые средства, чтобы запретить всем кроме методов класса, работать с его состоянием?

## <a id="q10">10. Инкапсуляция. Определение.</a>
В языке С++ для инкапсуляции (скрытия состояния объекта) используется специальный механизм, позволяющий сохранить видимость состояния.
```
template <typename T> class list_t {
	struct node_t;
	node_t *top_, *back_;
public:
	size_t length() const;
};
```

- В структуре по умолчанию все поля public;
- С приватной частью могут работать только методы класса (но Дружба – это магия);
  В хорошо спроектированной программе – друзей нет!

Особенности инкапсуляции:
- инкапсуляция - свойство типа, а не объектов;
- разные шаблонные параметры - разные типы!
- инкапсуляция делает критически важными конструкторы (так как состояние нельзя изменить извне) и деструкторы (так как очистить извне также нельзя)

## <a id="q11">11. Модификатор доступа в классе по умолчанию. Модификатор доступа в структуре по умолчанию.</a>

## <a id="q12">12. Наследование в классе по умолчанию.Наследование в структуре по умолчанию.</a>

## <a id="q13">13. Отличия private/protected/public (внутри определения класса и при наследовании).</a>

## <a id="q14">14. Отличие malloc/free от new/delete.</a>
C-шные **malloc** и **free** ничего не знают о конструкторах и деструкторах, поэтому используются **new** и **delete**, которые помимо выделения/очистки памяти вызывают конструктор/деструктор соответственно.

## <a id="q15">15. Когда не применима инициализация «в круглых скобках», «после =», «фигурная».</a>

## <a id="q16">16. Сужающие преобразованию и разные виды инициализации («в круглых скобках», «после =», «фигурная»).</a>

## <a id="q17">17. «Наиболее неприятный анализ» в С++ и разные виды инициализации («в круглых скобках», «фигурная»).</a>

## <a id="q18">18. В каких случаях возникает двойная инициализация? Как избежать?</a>

## <a id="q19">19. В каком порядке выполняется инициализация полей класса с использованием списков инициализации (в порядке расположения полей класса или в порядке, определенном в списке инициализации)?</a>

## <a id="q20">20. Что такое RVO? Пример?</a>

## <a id="q21">21. Полиморфизм. Определение. Виды полиморфизма.</a>

## <a id="q22">22. Примеры статического полиморфизма в С++.</a>

## <a id="q23">23. Примеры динамического полиморфизма в С++.</a>

## <a id="q24">24. Отличие overloading от overriding.</a>

## <a id="q25">25. Ключевое слово virtual.</a>

## <a id="q26">26. Ключевое слово override.</a>

## <a id="q27">27. Абстрактный класс. Определение.</a>

## <a id="q28">28. Использование аргументов со значениями по умолчанию в виртуальных функциях.</a>

## <a id="q29">29. NVI. Пример.</a>

## <a id="q30">30. Может ли существовать шаблон виртуального метода?</a>

## <a id="q31">31. Можно ли перегружать виртуальные функции?</a>

## <a id="q32">32. Как добавить в overloading set класса-наследника методы базового класса, являющиеся перегрузками виртуального метода?</a>

## <a id="q33">33. Чем плох GoTo?</a>

## <a id="q34">34. Примеры goto-маскирующих конструкций</a>

## <a id="q35">35. RAII. Концепция.</a>

## <a id="q36">36. Инвариант умного указателя с единственным (уникальным) владением.</a>

## <a id="q37">37. Drill down behaviour. Где применяется?</a>

## <a id="q38">38. Lvalue и rvalue. Отличия.</a>

## <a id="q39">39. Rvalue ссылки.</a>

## <a id="q40">40. Что делает std::move?</a>

## <a id="q41">41. Правило нуля, трех, пяти.</a>

## <a id="q42">42. Виды умных указателей.</a>

## <a id="q43">43. Отличие unique_ptr от shared_ptr.</a>

## <a id="q44">44. Отличие weak_ptr от shared_ptr.</a>

## <a id="q45">45. Способы инициализации shared_ptr.</a>

## <a id="q46">46. ODR.</a>

## <a id="q47">47. Include guards.</a>

## <a id="q48">48. CV-квалификаторы при выводе типов.</a>

## <a id="q49">49. Манглирование имен. (Как перегрузки функций представляются компилятором).</a>

## <a id="q50">50. Правила разрешения перегрузки для нешаблонных функций.</a>

## <a id="q51">51. Правила разрешения перегрузки для шаблонных функций.</a>

## <a id="q52">52. Что такое специализация шаблонного класса?</a>

## <a id="q53">53. Что такое частичная специализация шаблонного класса?</a>

## <a id="q54">54. Правила вывода типов для auto.</a>

## <a id="q55">55. Что делает decltype?</a>

## <a id="q56">56. Когда используем auto, а когда decltype для вывода типов?</a>

## <a id="q57">57. Когда С++ осуществляет «ленивые», а не «энергичные» вычисления?</a>

## <a id="q58">58. SFINAE. Определение.</a>

## <a id="q59">59. Зачем в старом С++ (до С++11) для реализации SFINAE создавались структуры разных размеров?</a>

## <a id="q60">60. Замена структурам разных размеров в современном С++.</a>

## <a id="q61">61. CRTP. Определение. Зачем нужно.</a>

## <a id="q62">62. Ограничения CRTP.</a>

## <a id="q63">63. Реализация чисто виртуальных функций в CRTP.</a>

## <a id="q64">64. Реализация виртуальных функций в CRTP.</a>

## <a id="q65">65. Реализация методов для удаления объекта класса в CRTP.</a>

## <a id="q66">66. Способы применения CRTP.</a>

## <a id="q67">67. Как применяется CRTP для делегирования?</a>

## <a id="q68">68. Как работает ключевое слово required? Когда проверятся ограничения?</a>

## <a id="q69">69. Чем плохи SFINAE ограничения? Приведите пример.</a>

## <a id="q70">70. Что такое requires-expression? Отличия required-expression от required-clause</a>

## <a id="q71">71. Виды requires-expression</a>

## <a id="q72">72. Что такое концепт? Особенности синтаксиса ограничения функций концептами</a>

## <a id="q73">73. Отношения между концептами</a>

## <a id="q74">74. Напишите концепт Hashable, принимающий одну шаблонную переменную T, который будет использоваться для проверки: существования типа std::hash<T>, существования std::hash<T>::operator() и приводимости типа возвращаемого значения std::hash<T>::operator() к std::size_t</a>

## <a id="q75">75. Универсальные ссылки и идеальная передача</a>

## <a id="q76">76. Функции std::move и std::forward</a>

## <a id="q77">77. Пачки параметров. Как выделить паттерн раскрытия? Что такое свертки?</a>

## <a id="q78">78. Паттерн Декоратор.</a>

## <a id="q79">79. Применение CRTP при реализации паттерна Декоратор.</a>

## <a id="q80">80. Паттерн Адаптер</a>

## <a id="q81">81. Минусы паттерна декоратор при реализации потокобезопасной очереди.</a>

## <a id="q82">82. Отличие паттерна декоратор от паттерна Адаптер.</a>

## <a id="q83">83. Паттерн Фабрика</a>

## <a id="q84">84. Как реализовать фабрику для инициализации объектов с разными аргументами в их конструкторах?</a>

## <a id="q85">85. Как реализовать полиморфное копирование с использованием фабрики?</a>

## <a id="q86">86. Зачем использовать CRTP в реализации полиморфного копирования с использованием фабрики?</a>

## <a id="q87">87. Паттерн Мост</a>

## <a id="q88">88. COW: достоинства и недостатки</a>

## <a id="q89">89. Паттерн Компоновщик</a>

## <a id="q90">90. Паттерн Строитель</a>
