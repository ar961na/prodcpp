[1-3. Cmake](#q1)


[4-6. Git](#q4)


[7. waterfall vs agile](#q7)


[8. Алгоритм Флойда](#q8)


[9. Инварианты класса](#q9)


[10. Инкапсуляция](#q10)


[11. Модификатор доступа](#q11)


[12. Наследование](#q12)


[13. private / protected / public](#q13)


[14. malloc/free vs new/delete](#q14)


[15. Инициализация](#q15)


[16. Сужающие преобразования](#q16)


[17. «Наиболее неприятный анализ»](#q17)


[18. Двойная инициализация](#q18)


[19. Порядок инициализации](#q19)


[20. RVO](#q20)


[21-23. Полиморфизм](#q21)


[24. overloading vs overriding](#q24)


[25. virtual](#q25)


[26. override](#q26)


[27. Абстрактный класс](#q27)


[28. Значение по умолчанию](#q28)


[29. NVI](#q29)


[30. Может существовать шаблон виртуального метода?](#q30)


[31. Можно ли перегружать вирутальные функции?](#q31)


[32. overloading set](#q32)


[33-34. GoTo](#q33)


[35. RAII](#q35)


[36. Инвариант умного указателя с удинственным владением](#q36)


[37. Drill down behaviour](#q37)


[38-39. lvalue и rvalue](#q38)


[40. std::move](#q40)


[41. Правило 0, 3, 5](#q41)


[42-45. Умные указатели](#q42)


[46. ODR](#q46)


[47. Include guards](#q47)


[48. CV-квалификарторы](#q48)


[49. Манглирование имен](#q49)


[50-51. Перегрузки функций](#q50)


[52-53. Специализация классов](#q52)


[54. auto и decltype](#q54)


[57. «ленивые» и «энергичные» вычисления](#q57)


[58-59. SFINAE](#q58)


[60. Замена структурам разных размеров с современном C++](#q60)


[61-67. CRTP](#q61)


[68-71. required](#q68)


[72-74. concept](#q72)


[75. Универсальные ссылки и идеальная передача](#q75)


[76. std::move и std::forward](#q76)


[77. Пачки параметров. Свертки](#q77)


[78-90. Паттерны](#q78)

## <a id="q1">1. Cmake. Написать Cmake для проекта, состоящего из main.cpp, class1.h, class1.cpp. Стандарт С++-17.</a>
```
cmake_minimum_required(VERSION 3.5)
project(question1)

set(CMAKE_CXX_STANDARD 17)

set(HEADERS class1.h)
set(SOURCES main.cpp class1.cpp)

add_executable(${PROJECT_NAME} ${SOURCES} ${HEADERS})
```

Алгоритм сборки проекта с использованием Cmake:
1. Создать каталог сборки (например build) на уровне основного CmakeLists.txt и перейти в него.
2. ```cmake -DCMAKE_BUILD_TYPE=Debug/Release ..```
   Данная команда сгенерирует необходимые файлы для сборки проекта в соответствии с конфигурацией.
	Примечание: «..» предназначен для выполнения CmakeLists.txt, находящегося на уровень выше текущего положения.
3. ```Cmake --build . –jX```
   Х – максимальное количество одновременных процессов для использования при сборке.

## <a id="q2">2. Cmake. Алгоритм сборки библиотеки без зависимостей из исходных кодов, которые содержат CmakeLists.txt.</a>
```
cmake_minimum_required(VERSION 3.5)
project(question2)

set(CMAKE_CXX_STANDARD 17)

set(SOURCE_EXE main.cpp)
set(SOURCE_LIB foo.cpp)

add_library(foo STATIC ${SOURCE_LIB})
add_executable(main ${SOURCE_EXE})

target_link_libraries(main foo)
```

## <a id="q3">3. Cmake. Добавление сторонней прекомпилированной библиотеки к своему проекту.</a>
```
cmake_minimum_required(VERSION 3.5)
project(question3)

find_package(MyExternalLibrary REQUIRED)

add_executable(MyExecutable main.cpp)
target_link_libraries(MyExecutable PRIVATE MyExternalLibrary::MyExternalLibrary)
```

## <a id="q4">4. Git. Отличие checkout от switch.</a>
- Создание ветки и переход:
  
	`git checkout –b <Название новой ветки>`

	`git switch –c <Название новой ветки>`
- Переход на другую ветку:

	`git checkout <Название ветки>`

	`git switch <Название ветки>`

Отличие между **git checkout** и **git switch**: **git checkout** используется при переключение веток/для отката изменений в определенном файле

В новых версиях git функционал checkout разделен на:
- **git switch** – работа с ветками;
- **git restore** – работа с файлами.

## <a id="q5">5. Git. Отличия rebase/merge/cherry-pick.</a>
- **merge** - объединяет изменения из одной ветки в другую, создавая новый коммит, если есть слияния

	`git merge feature-branch`

- **rebase** - перемещает или переигрывает коммиты из одной ветки в другую, переписывая историю

	`git rebase main`

- **cherry-pick** - применяет конкретные коммиты из одной ветки в другую без слияния всей ветки

	`git cherry-pick <commit-hash>`

## <a id="q6">6. Git. Что нужно сделать, чтобы зафиксировать изменения в локальном репозитории и добавить их в удаленный репозиторий.</a>
```
# Добавление изменений в индекс (стадия)
git add 

# Фиксация изменений в локальном репозитории
git commit -m "Описание изменений"

# Отправка изменений в удаленный репозиторий
git push origin main
```

## <a id="q7">7. Отличия waterfall от agile.</a>
Waterfall (Каскадная модель): Линейная и последовательная модель разработки, где каждая фаза должна быть завершена перед началом следующей.

- Жесткий порядок этапов (требования, дизайн, реализация, тестирование, развертывание).
- Подходит для проектов с четкими и неизменными требованиями.

Agile (Гибкие методологии): Инкрементная и итеративная модель, ориентированная на гибкость и адаптацию к изменениям.

- Разработка происходит в коротких циклах (итерациях).
- Частые релизы и обратная связь от пользователей.
- Приветствуются изменения требований даже на поздних этапах.

## <a id="q8">8. Алгоритм Флойда.</a>
1. Начинают два указателя: заяц и черепаха;
2. Заяц за один ход продвигается вперед на два элемента, а черепаха на один;
3. Если они встретились, значит петля есть.

Проблемы подхода:
- Если необходимо написать метод reverse?
- Опять использовать алгоритм Флойда, проверяя нет ли петель и тем самым удваивать время работы?

## <a id="q9">9. Инварианты класса. Определение.</a>
- Предусловия эффективного метода reverse – список корректен, начинается и заканчивается нулем, без петлей;
- Проверять каждый раз – неэффективно и дорого;
- Утверждение, которое должно быть верно все время жизни объекта класса называется его инвариантом;
- Все методы списка упростятся, если будет гарантировано сохранение инвариант списка;
- Кто должен гарантировать сохранение инварианта?
  Гарантировать сохранение инвариантов в методе – обязанность разработчика.

Проблемы инвариантов:
- Однако, как запретить внешним функциям нарушать инварианты у объектов?
- Есть ли в С++ языковые средства, чтобы запретить всем кроме методов класса, работать с его состоянием?

## <a id="q10">10. Инкапсуляция. Определение.</a>
В языке С++ для инкапсуляции (скрытия состояния объекта) используется специальный механизм, позволяющий сохранить видимость состояния.
```
template <typename T> class list_t {
	struct node_t;
	node_t *top_, *back_;
public:
	size_t length() const;
};
```

- В структуре по умолчанию все поля public;
- С приватной частью могут работать только методы класса (но Дружба – это магия);
  В хорошо спроектированной программе – друзей нет!

Особенности инкапсуляции:
- инкапсуляция - свойство типа, а не объектов;
- разные шаблонные параметры - разные типы!
- инкапсуляция делает критически важными конструкторы (так как состояние нельзя изменить извне) и деструкторы (так как очистить извне также нельзя)

## <a id="q11">11. Модификатор доступа в классе по умолчанию. Модификатор доступа в структуре по умолчанию.</a>

В классе по умолчанию модификатор доступа - **private**.

В структуре по умолчаю модификатор доступа - **public**.

## <a id="q12">12. Наследование в классе по умолчанию.Наследование в структуре по умолчанию.</a>

Наследование - концепция ООП, которая позволяет определять новые классы как расширение существующих. Различают открытое (A является B) и закрытое (A содержит B).

Открытое наследование = контракт, где мы обещаем клиенту, что класс поддерживает методы класса родителя, сохраняет инварианты и тому подобное.

В классе по умолчанию тип наследования - **private**.

В структуре по умолчаю тип наследования - **public**.

## <a id="q13">13. Отличия private/protected/public (внутри определения класса и при наследовании).</a>

- private:
  Доступен только внутри самого класса. При наследовании private члены остаются недоступными для производного класса.
- protected:
  Доступен внутри самого класса и производных классов. При наследовании protected члены остаются доступными для производного класса и его производных.
- public:
  Доступен везде, где доступен объект. При наследовании public члены остаются доступными для всех.

```
class Base {
private:
    int privateVar;
protected:
    int protectedVar;
public:
    int publicVar;
};

class Derived : public Base {
    void access() {
        // privateVar недоступен
        protectedVar = 1; // доступен
        publicVar = 2; // доступен
    }
};
```

## <a id="q14">14. Отличие malloc/free от new/delete.</a>
C-шные **malloc** и **free** ничего не знают о конструкторах и деструкторах, поэтому используются **new** и **delete**, которые помимо выделения/очистки памяти вызывают конструктор/деструктор соответственно.

## <a id="q15">15. Когда не применима инициализация «в круглых скобках», «после =», «фигурная».</a>

```
list_t<int> T1;		// Вызов конструктора по умолчанию
list_t<int> T2 = T1;	// Не присваивание, а конструктор копирования
T1 = T2;		// Присваивание; вызов оператора operator=()

int x(0);	// Инициализатор в круглых скобках
int y = 0; 	// Инициализатор после "="
int z{ 0 };	// Инициализатор в круглых скобках - унифицированная инициализация
```

Инициализация полей класса по умолчанию:
```
class Point {
	...
private:
	int x{ 0 };	// ОК, значение x по умолчанию равно 0
	int y = 0; 	// Тоже ОК
	int z(0);	// Ошибка!
};
```

Для некопируемых объектов:
```
std::atomic<int> ai1 { 0 };	// OK
std::atomic<int> ai2 (0);	// OK
std::atomic<int> ai3 = 0;	// Ошибка!
```

## <a id="q16">16. Сужающие преобразованию и разные виды инициализации («в круглых скобках», «после =», «фигурная»).</a>

Особенности унифицированной инициализации: запрет сужающих преобразований
```
double x, y, z;

int sum1 { x + y + z };		// Warning/Error в зависимости от флагов компилятора
int sum2 ( x + y + z );		// OK
int sum3 = x + y + z;		// OK
```

## <a id="q17">17. «Наиболее неприятный анализ» в С++ и разные виды инициализации («в круглых скобках», «фигурная»).</a>

«Наиболее неприятный анализ» (Most Vexing Parse) - это ситуация, когда синтаксис C++ может быть неоднозначным.

### Пример 1:
```
class list_t {};

class my_class_t {
public:
	int x = 42;
	my_class_t(list_t, list_t) {};
}

int main (int argc, char** argv) {
	my_class_t m1(list_t(), list_t());
	std::cout << m1.x << std::endl;
	my_class_t m2 { list_t(), list_t() };
	std::cout << m2.x << std::endl;
}
```

Что будет выведено в обоих случаях?

> error: request for member 'x' in m1, which is of non-class type 'my_class_t(list_t (`*`)(), list_t (`*`)())' std::cout << m1.x << std::endl;

### Пример 2:

```
std::vector<int> a(10, 20);
std::vector<int> b{ 10, 20 };
std::cout << a.size() << " " << b.size() << std::endl;
```

Что будет выведено?

> 10 2

Так как при наличии конструктора, принимающего *std::initializer_list в качестве аргумента, будет использован именно этот конструктор даже когда он подходит не лучшим образом.

## <a id="q18">18. В каких случаях возникает двойная инициализация? Как избежать?</a>

```
#include <iostream>

struct S {
	S() { std::cout << "default" << std::endl; };
	S(int key) { std::cout << "direct" << std::endl; };
};

struct Node1 {
	S key_;
	int val_;
	Node1 (int key, int val) { key_ = key; val_ = val; };		// Двойная инициализация!!!
};

struct Node2 {
	S key_;
	int val_;
	Node2 (int key, int val) : key_{ key }, val_{ val } {};
};

int main (int argc, char** argv) {
	Node1 a(2, 3);			//!!!
	Node2 b(2, 3);
}
```

Присваивая в теле конструктора мы инициализируем дважды.

Чтобы уйти от двойной инициализации предусмотрены списки инициализации.

## <a id="q19">19. В каком порядке выполняется инициализация полей класса с использованием списков инициализации (в порядке расположения полей класса или в порядке, определенном в списке инициализации)?</a>

Список инициализации выполняется строго в том порядке, в каком поля определены в классе (а не в том, в каком они записаны в списке).

## <a id="q20">20. Что такое RVO? Пример?</a>

RVO (Return Value Optimization) - оптимизация компилятора, позволяющая в некоторых случаях не создавать локальный объект, который будет использован как возвращающее значение. Вместо этого возвращаемый объект будет сконструирован на месте вызова функции. Это позоваляет устранить лишний вызов конструктора перемещения/копирования.

```
struct foo {
	foo() { std::cout << "1 " << std::endl; };
	foo(const foo&) { std::cout << "2" << std::endl; };
	~foo() { std::cout << "3" << std::endl; };
}

void aa(const foo& f) { std::cout << "AA" << std::endl; };
foo bar() { foo loc_foo; return loc_foo; }

int main (int argc, char** argv) {
	foo f = bar();
	aa(f);
}
```

## <a id="q21">21. Полиморфизм. Определение. Виды полиморфизма.</a>

Полиморфизм - концепция ООП, которая позволяет для единого интерфейса представить множество реализаций в зависимости от аргументов.

Виды полиморфизма:
- **статический** (выбор реализации осуществляется во время компиляции) - перегрузки функций, шаблоны;
- **динамический** (выбор реализации осуществляется во время выполнения) - виртуальные функции.

## <a id="q22">22. Примеры статического полиморфизма в С++.</a>

```
template<typename T>
class Calculator {
public:
    	T add(T a, T b) {
        	return a + b;
    	}
};

Calculator<int> intCalc;
int result = intCalc.add(3, 5);
```

## <a id="q23">23. Примеры динамического полиморфизма в С++.</a>

```
class Shape {
public:
    	virtual void draw() const {
        	std::cout << "Drawing Shape" << std::endl;
    	}
    	virtual ~Shape() = default;
};

class Circle : public Shape {
public:
    	void draw() const override {
        	std::cout << "Drawing Circle" << std::endl;
    	}
};

Shape* shape = new Circle();
shape->draw(); // Вызовет Circle::draw
delete shape;

```

## <a id="q24">24. Отличие overloading от overriding.</a>

- Перегрузка функции (**overloading**) - введение того же имени с лругими типами аргументов;
- Переопределение функции (**overriding**) - замещение в классе наследнике виртуальной функции класса родителя.

## <a id="q25">25. Ключевое слово virtual.</a>

Ключевое слово **virtual** используется для создания виртуальных функций, которые могут быть переопределены в производных классах. Это позволяет добиться динамического полиморфизма.

## <a id="q26">26. Ключевое слово override.</a>

Аннотация override - требует переопределения.

## <a id="q27">27. Абстрактный класс. Определение.</a>

- Классы, в котором все методы чисто виртуальные служит своего рода общим;
- Класс, содержащий хотя бы одну чисто виртуальную функцию, называется абстрактным базовым классом;
- Виртуальный конструктор (в том числе копирующий) - невозможен.

## <a id="q28">28. Использование аргументов со значениями по умолчанию в виртуальных функциях.</a>

Аргументы по умолчанию для виртуальных функций должны быть заданы в базовом классе. Они будут использованы, если производный класс не переопределит эти значения.

```
class Base {
public:
    	virtual void display(int x = 5) {
       	 	std::cout << "Base: " << x << std::endl;
    	}
};

class Derived : public Base {
public:
    	void display(int x = 10) override {
        	std::cout << "Derived: " << x << std::endl;
    	}
};

int main (int argc, char** argv) {
	Base* b = new Derived();
	b->display(); 				// Выведет "Derived: 5"
}
```

## <a id="q29">29. NVI. Пример.</a>

NVI (Non-Virtual Interface):
- аргументы по умолчанию связываются статически, то есть зависят от статического типа;
- если нужен интерфейс с аргументами по умолчанию, его можно сделать невиртуальным, чтобы никто не смог из переопределить.

```
struct BaseNVI {
	int foo (int x = 14) { return foo_impl(x); };
private:
	virtual int foo_impl (int a) { return a; };
};

struct DerivedNVI {
	int foo_impl (int a) override { return a * 2; };
};
```

## <a id="q30">30. Может ли существовать шаблон виртуального метода?</a>

К счастью - нет.

## <a id="q31">31. Можно ли перегружать виртуальные функции?</a>

К сожалению - да.

## <a id="q32">32. Как добавить в overloading set класса-наследника методы базового класса, являющиеся перегрузками виртуального метода?</a>

## <a id="q33">33. Чем плох GoTo?</a>

## <a id="q34">34. Примеры goto-маскирующих конструкций</a>

## <a id="q35">35. RAII. Концепция.</a>

## <a id="q36">36. Инвариант умного указателя с единственным (уникальным) владением.</a>

## <a id="q37">37. Drill down behaviour. Где применяется?</a>

## <a id="q38">38. Lvalue и rvalue. Отличия.</a>

## <a id="q39">39. Rvalue ссылки.</a>

## <a id="q40">40. Что делает std::move?</a>

## <a id="q41">41. Правило нуля, трех, пяти.</a>

## <a id="q42">42. Виды умных указателей.</a>

## <a id="q43">43. Отличие unique_ptr от shared_ptr.</a>

## <a id="q44">44. Отличие weak_ptr от shared_ptr.</a>

## <a id="q45">45. Способы инициализации shared_ptr.</a>

## <a id="q46">46. ODR.</a>

## <a id="q47">47. Include guards.</a>

## <a id="q48">48. CV-квалификаторы при выводе типов.</a>

## <a id="q49">49. Манглирование имен. (Как перегрузки функций представляются компилятором).</a>

## <a id="q50">50. Правила разрешения перегрузки для нешаблонных функций.</a>

## <a id="q51">51. Правила разрешения перегрузки для шаблонных функций.</a>

## <a id="q52">52. Что такое специализация шаблонного класса?</a>

## <a id="q53">53. Что такое частичная специализация шаблонного класса?</a>

## <a id="q54">54. Правила вывода типов для auto.</a>

## <a id="q55">55. Что делает decltype?</a>

## <a id="q56">56. Когда используем auto, а когда decltype для вывода типов?</a>

## <a id="q57">57. Когда С++ осуществляет «ленивые», а не «энергичные» вычисления?</a>

## <a id="q58">58. SFINAE. Определение.</a>

## <a id="q59">59. Зачем в старом С++ (до С++11) для реализации SFINAE создавались структуры разных размеров?</a>

## <a id="q60">60. Замена структурам разных размеров в современном С++.</a>

## <a id="q61">61. CRTP. Определение. Зачем нужно.</a>

## <a id="q62">62. Ограничения CRTP.</a>

## <a id="q63">63. Реализация чисто виртуальных функций в CRTP.</a>

## <a id="q64">64. Реализация виртуальных функций в CRTP.</a>

## <a id="q65">65. Реализация методов для удаления объекта класса в CRTP.</a>

## <a id="q66">66. Способы применения CRTP.</a>

## <a id="q67">67. Как применяется CRTP для делегирования?</a>

## <a id="q68">68. Как работает ключевое слово required? Когда проверятся ограничения?</a>

## <a id="q69">69. Чем плохи SFINAE ограничения? Приведите пример.</a>

## <a id="q70">70. Что такое requires-expression? Отличия required-expression от required-clause</a>

## <a id="q71">71. Виды requires-expression</a>

## <a id="q72">72. Что такое концепт? Особенности синтаксиса ограничения функций концептами</a>

## <a id="q73">73. Отношения между концептами</a>

## <a id="q74">74. Напишите концепт Hashable, принимающий одну шаблонную переменную T, который будет использоваться для проверки: существования типа std::hash<T>, существования std::hash<T>::operator() и приводимости типа возвращаемого значения std::hash<T>::operator() к std::size_t</a>

## <a id="q75">75. Универсальные ссылки и идеальная передача</a>

## <a id="q76">76. Функции std::move и std::forward</a>

## <a id="q77">77. Пачки параметров. Как выделить паттерн раскрытия? Что такое свертки?</a>

## <a id="q78">78. Паттерн Декоратор.</a>

## <a id="q79">79. Применение CRTP при реализации паттерна Декоратор.</a>

## <a id="q80">80. Паттерн Адаптер</a>

## <a id="q81">81. Минусы паттерна декоратор при реализации потокобезопасной очереди.</a>

## <a id="q82">82. Отличие паттерна декоратор от паттерна Адаптер.</a>

## <a id="q83">83. Паттерн Фабрика</a>

## <a id="q84">84. Как реализовать фабрику для инициализации объектов с разными аргументами в их конструкторах?</a>

## <a id="q85">85. Как реализовать полиморфное копирование с использованием фабрики?</a>

## <a id="q86">86. Зачем использовать CRTP в реализации полиморфного копирования с использованием фабрики?</a>

## <a id="q87">87. Паттерн Мост</a>

## <a id="q88">88. COW: достоинства и недостатки</a>

## <a id="q89">89. Паттерн Компоновщик</a>

## <a id="q90">90. Паттерн Строитель</a>
