[1-3. Cmake](#q1)


[4-6. Git](#q4)


[7. waterfall vs agile](#q7)


[8. Алгоритм Флойда](#q8)


[9. Инварианты класса](#q9)


[10. Инкапсуляция](#q10)


[11. Модификатор доступа](#q11)


[12. Наследование](#q12)


[13. private / protected / public](#q13)


[14. malloc/free vs new/delete](#q14)


[15. Инициализация](#q15)


[16. Сужающие преобразования](#q16)


[17. «Наиболее неприятный анализ»](#q17)


[18. Двойная инициализация](#q18)


[19. Порядок инициализации](#q19)


[20. RVO](#q20)


[21-23. Полиморфизм](#q21)


[24. overloading vs overriding](#q24)


[25. virtual](#q25)


[26. override](#q26)


[27. Абстрактный класс](#q27)


[28. Значение по умолчанию](#q28)


[29. NVI](#q29)


[30. Может существовать шаблон виртуального метода?](#q30)


[31. Можно ли перегружать вирутальные функции?](#q31)


[32. overloading set](#q32)


[33-34. GoTo](#q33)


[35. RAII](#q35)


[36. Инвариант умного указателя с удинственным владением](#q36)


[37. Drill down behaviour](#q37)


[38-39. lvalue и rvalue](#q38)


[40. std::move](#q40)


[41. Правило 0, 3, 5](#q41)


[42-45. Умные указатели](#q42)


[46. ODR](#q46)


[47. Include guards](#q47)


[48. CV-квалификарторы](#q48)


[49. Манглирование имен](#q49)


[50-51. Перегрузки функций](#q50)


[52-53. Специализация классов](#q52)


[54. auto и decltype](#q54)


[57. «ленивые» и «энергичные» вычисления](#q57)


[58-59. SFINAE](#q58)


[60. Замена структурам разных размеров с современном C++](#q60)


[61-67. CRTP](#q61)


[68-71. required](#q68)


[72-74. concept](#q72)


[75. Универсальные ссылки и идеальная передача](#q75)


[76. std::move и std::forward](#q76)


[77. Пачки параметров. Свертки](#q77)


[78-90. Паттерны](#q78)

## <a id="q1">1. Cmake. Написать Cmake для проекта, состоящего из main.cpp, class1.h, class1.cpp. Стандарт С++-17.</a>

## <a id="q2">2. Cmake. Алгоритм сборки библиотеки без зависимостей из исходных кодов, которые содержат CmakeLists.txt.</a>

## <a id="q3">3. Cmake. Добавление сторонней прекомпилированной библиотеки к своему проекту.</a>

## <a id="q4">4. Git. Отличие checkout от switch.</a>

## <a id="q5">5. Git. Отличия rebase/merge/cherry-pick.</a>

## <a id="q6">6. Git. Что нужно сделать, чтобы зафиксировать изменения в локальном репозитории и добавить их в удаленный репозиторий.</a>

## <a id="q7">7. Отличия waterfall от agile.</a>

## <a id="q8">8. Алгоритм Флойда.</a>

## <a id="q9">9. Инварианты класса. Определение.</a>

## <a id="q10">10. Инкапсуляция. Определение.</a>

## <a id="q11">11. Модификатор доступа в классе по умолчанию. Модификатор доступа в структуре по умолчанию.</a>

## <a id="q12">12. Наследование в классе по умолчанию.Наследование в структуре по умолчанию.</a>

## <a id="q13">13. Отличия private/protected/public (внутри определения класса и при наследовании).</a>

## <a id="q14">14. Отличие malloc/free от new/delete.</a>

## <a id="q15">15. Когда не применима инициализация «в круглых скобках», «после =», «фигурная».</a>

## <a id="q16">16. Сужающие преобразованию и разные виды инициализации («в круглых скобках», «после =», «фигурная»).</a>

## <a id="q17">17. «Наиболее неприятный анализ» в С++ и разные виды инициализации («в круглых скобках», «фигурная»).</a>

## <a id="q18">18. В каких случаях возникает двойная инициализация? Как избежать?</a>

## <a id="q19">19. В каком порядке выполняется инициализация полей класса с использованием списков инициализации (в порядке расположения полей класса или в порядке, определенном в списке инициализации)?</a>

## <a id="q20">20. Что такое RVO? Пример?</a>

## <a id="q21">21. Полиморфизм. Определение. Виды полиморфизма.</a>

## <a id="q22">22. Примеры статического полиморфизма в С++.</a>

## <a id="q23">23. Примеры динамического полиморфизма в С++.</a>

## <a id="q24">24. Отличие overloading от overriding.</a>

## <a id="q25">25. Ключевое слово virtual.</a>

## <a id="q26">26. Ключевое слово override.</a>

## <a id="q27">27. Абстрактный класс. Определение.</a>

## <a id="q28">28. Использование аргументов со значениями по умолчанию в виртуальных функциях.</a>

## <a id="q29">29. NVI. Пример.</a>

## <a id="q30">30. Может ли существовать шаблон виртуального метода?</a>

## <a id="q31">31. Можно ли перегружать виртуальные функции?</a>

## <a id="q32">32. Как добавить в overloading set класса-наследника методы базового класса, являющиеся перегрузками виртуального метода?</a>

## <a id="q33">33. Чем плох GoTo?</a>

## <a id="q34">34. Примеры goto-маскирующих конструкций</a>

## <a id="q35">35. RAII. Концепция.</a>

## <a id="q36">36. Инвариант умного указателя с единственным (уникальным) владением.</a>

## <a id="q37">37. Drill down behaviour. Где применяется?</a>

## <a id="q38">38. Lvalue и rvalue. Отличия.</a>

## <a id="q39">39. Rvalue ссылки.</a>

## <a id="q40">40. Что делает std::move?</a>

## <a id="q41">41. Правило нуля, трех, пяти.</a>

## <a id="q42">42. Виды умных указателей.</a>

## <a id="q43">43. Отличие unique_ptr от shared_ptr.</a>

## <a id="q44">44. Отличие weak_ptr от shared_ptr.</a>

## <a id="q45">45. Способы инициализации shared_ptr.</a>

## <a id="q46">46. ODR.</a>

## <a id="q47">47. Include guards.</a>

## <a id="q48">48. CV-квалификаторы при выводе типов.</a>

## <a id="q49">49. Манглирование имен. (Как перегрузки функций представляются компилятором).</a>

## <a id="q50">50. Правила разрешения перегрузки для нешаблонных функций.</a>

## <a id="q51">51. Правила разрешения перегрузки для шаблонных функций.</a>

## <a id="q52">52. Что такое специализация шаблонного класса?</a>

## <a id="q53">53. Что такое частичная специализация шаблонного класса?</a>

## <a id="q54">54. Правила вывода типов для auto.</a>

## <a id="q55">55. Что делает decltype?</a>

## <a id="q56">56. Когда используем auto, а когда decltype для вывода типов?</a>

## <a id="q57">57. Когда С++ осуществляет «ленивые», а не «энергичные» вычисления?</a>

## <a id="q58">58. SFINAE. Определение.</a>

## <a id="q59">59. Зачем в старом С++ (до С++11) для реализации SFINAE создавались структуры разных размеров?</a>

## <a id="q60">60. Замена структурам разных размеров в современном С++.</a>

## <a id="q61">61. CRTP. Определение. Зачем нужно.</a>

## <a id="q62">62. Ограничения CRTP.</a>

## <a id="q63">63. Реализация чисто виртуальных функций в CRTP.</a>

## <a id="q64">64. Реализация виртуальных функций в CRTP.</a>

## <a id="q65">65. Реализация методов для удаления объекта класса в CRTP.</a>

## <a id="q66">66. Способы применения CRTP.</a>

## <a id="q67">67. Как применяется CRTP для делегирования?</a>

## <a id="q68">68. Как работает ключевое слово required? Когда проверятся ограничения?</a>

## <a id="q69">69. Чем плохи SFINAE ограничения? Приведите пример.</a>

## <a id="q70">70. Что такое requires-expression? Отличия required-expression от required-clause</a>

## <a id="q71">71. Виды requires-expression</a>

## <a id="q72">72. Что такое концепт? Особенности синтаксиса ограничения функций концептами</a>

## <a id="q73">73. Отношения между концептами</a>

## <a id="q74">74. Напишите концепт Hashable, принимающий одну шаблонную переменную T, который будет использоваться для проверки: существования типа std::hash<T>, существования std::hash<T>::operator() и приводимости типа возвращаемого значения std::hash<T>::operator() к std::size_t</a>

## <a id="q75">75. Универсальные ссылки и идеальная передача</a>

## <a id="q76">76. Функции std::move и std::forward</a>

## <a id="q77">77. Пачки параметров. Как выделить паттерн раскрытия? Что такое свертки?</a>

## <a id="q78">78. Паттерн Декоратор.</a>

## <a id="q79">79. Применение CRTP при реализации паттерна Декоратор.</a>

## <a id="q80">80. Паттерн Адаптер</a>

## <a id="q81">81. Минусы паттерна декоратор при реализации потокобезопасной очереди.</a>

## <a id="q82">82. Отличие паттерна декоратор от паттерна Адаптер.</a>

## <a id="q83">83. Паттерн Фабрика</a>

## <a id="q84">84. Как реализовать фабрику для инициализации объектов с разными аргументами в их конструкторах?</a>

## <a id="q85">85. Как реализовать полиморфное копирование с использованием фабрики?</a>

## <a id="q86">86. Зачем использовать CRTP в реализации полиморфного копирования с использованием фабрики?</a>

## <a id="q87">87. Паттерн Мост</a>

## <a id="q88">88. COW: достоинства и недостатки</a>

## <a id="q89">89. Паттерн Компоновщик</a>

## <a id="q90">90. Паттерн Строитель</a>
